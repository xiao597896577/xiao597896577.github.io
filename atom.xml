<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[My Octopress Blog]]></title>
  <link href="http://xiao597896577.github.io/atom.xml" rel="self"/>
  <link href="http://xiao597896577.github.io/"/>
  <updated>2014-03-25T23:07:22+08:00</updated>
  <id>http://xiao597896577.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[POJ 2965 The Pilots Brothers' refrigerator]]></title>
    <link href="http://xiao597896577.github.io/blog/2014/03/25/poj-2965-the-pilots-brothers-refrigerator/"/>
    <updated>2014-03-25T22:37:04+08:00</updated>
    <id>http://xiao597896577.github.io/blog/2014/03/25/poj-2965-the-pilots-brothers-refrigerator</id>
    <content type="html"><![CDATA[<h1>POJ 2965 The Pilots Brothers&#8217; Refrigerator</h1>

<h2>1.原题</h2>

<p><strong>Description</strong></p>

<p>The game “The Pilots Brothers: following the stripy elephant” has a quest where a player needs to open a refrigerator.</p>

<p>There are 16 handles on the refrigerator door. Every handle can be in one of two states: open or closed. The refrigerator is open only when all handles are open. The handles are represented as a matrix 4х4. You can change the state of a handle in any location [i, j] (1 ≤ i, j ≤ 4). However, this also changes states of all handles in row i and all handles in column j.</p>

<p>The task is to determine the minimum number of handle switching necessary to open the refrigerator.</p>

<p><strong>Input</strong></p>

<p>The input contains four lines. Each of the four lines contains four characters describing the initial state of appropriate handles. A symbol “+” means that the handle is in closed state, whereas the symbol “−” means “open”. At least one of the handles is initially closed.</p>

<p><strong>Output</strong></p>

<p>The first line of the input contains N – the minimum number of switching. The rest N lines describe switching sequence. Each of the lines contains a row number and a column number of the matrix separated by one or more spaces. If there are several solutions, you may give any one of them.</p>

<p><strong>Sample Input</strong><br>
-+ - -<br>
- - - -<br>
- - - -<br>
-+ - -</p>

<p><strong>Sample Output</strong></p>

<p>6<br>
1 1<br>
1 3<br>
1 4<br>
4 1<br>
4 3<br>
4 4</p>

<h2>2.题意</h2>

<p>题目意思就是有一个4×4的方格，然后是要你从里面任意选择出一个格子，然后它自己，以及它所在行，它所在列的所有的位置都变成相反的，比如‘+’变成‘-’，‘-’变成‘+’，然后问你，最少选多少次格子，可以让所有格子都变成‘-’</p>

<h2>3.思路</h2>

<p>思路的话，很简单了，此题和上面的POJ1753是一个类型的，基本就是照办，就是位运算+队列的压缩存储状态,这里面多了一个，就是要输出每一步，这样的话，就用了数组来存储每次保存的状态，然后递归来输出结果</p>

<h2>4.代码</h2>

<pre>
  <code>
#include&lt;iostream>
#include&lt;queue>
#include&lt;cstring>
#include&lt;string>
#include&lt;string.h>
#define M 65535

using namespace std;

struct state
{
    int data;
    int step;
    int pre;
    int pos;
};

int dir[16] = {4383,8751,17487,34959,4593,8946,17652,35064,7953,12066,20292,36744,61713,61986,62532,63624};
queue<state> sList;
int visList[M+1];

state ssList[(1<<16) +1];

void printP(state s) {
    if(s.pre != -1){
        printP(ssList[s.pre]);
        cout&lt;&lt; s.pos / 4 + 1&lt;&lt;" "&lt;&lt;s.pos % 4 + 1&lt;&lt;endl;
    }
}

void getResult(){

    state ss;
    bool op = false;
    while(!sList.empty()){

        ss = sList.front();
        sList.pop();

        if(ss.data == M) {
            cout&lt;&lt;ss.step&lt;&lt;&lt;endl;
            printP(ss);
            break;
        }

        for (int i = 0; i<16;i++) {
            int temp = ss.data ^ dir[15-i];
            if(visList[temp]) continue;
            state sss;
            sss.data = temp;
            sss.step = ss.step + 1;
            sss.pre = ss.data;
            sss.pos = i;
            ssList[sss.data] = sss;
            visList[temp] = 1;
            sList.push(sss);
        }

    }
}

int main(){
    while(!sList.empty()) sList.pop();
    memset(visList,0,sizeof(visList));
    memset(ssList,0,sizeof(ssList));
    state start;
    int data = 0;
    string s;
    for (int i = 0; i < 4; i++) {
        cin>>s;
        const char* map = s.c_str();
        for (int j=0;j<4;j++) {
            if(map[j] == '-')
                data = (data << 1) + 1;
            else 
                data = (data << 1);
        }
    }
    visList[data] = 1;
    start.data = data;
    start.step = 0;
    start.pre = -1;
    sList.push(start);
    ssList[data] = start;
    getResult();

    return 0;
}

  </code>
</pre>


<h2>5.后续</h2>

<p>1）其实这道题先开始是TLE的，主要是因为先开始我维护的是一张string的路径，即存储在struct里面的，每次都进行添加每次的行走的路线，不知道是因为string的操作运行时间太长还是其他什么原因，就是会TLE，而且在cmd中显示还会卡壳的。后来用数字的话，速度就快多了。这个还要再看一下。</p>

<p>2）就是这个题先开始用c++的编译器的时候，会报TLE的，但是后来我改成G++的编译器后，就没有TLE了，直接AC。这个原因也要再查一下</p>

<p>3）吐槽一下，这道题花了一个晚上，感觉有点坑爹，但是是自己的第二道位运算，现在感觉位运算了解一些了吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[POJ 1753 Flip Game]]></title>
    <link href="http://xiao597896577.github.io/blog/2014/03/25/poj-1753-flip-game/"/>
    <updated>2014-03-25T11:28:42+08:00</updated>
    <id>http://xiao597896577.github.io/blog/2014/03/25/poj-1753-flip-game</id>
    <content type="html"><![CDATA[<h1>POJ 1753-Flip Game</h1>

<h2>1.原题</h2>

<p><strong>Description</strong></p>

<p>Flip game is played on a rectangular 4x4 field with two-sided pieces placed on each of its 16 squares. One side of each piece is white and the other one is black and each piece is lying either it&rsquo;s black or white side up. Each round you flip 3 to 5 pieces, thus changing the color of their upper side from black to white and vice versa. The pieces to be flipped are chosen every round according to the following rules: <br>
 1.Choose any one of the 16 pieces. <br>
 2.Flip the chosen piece and also all adjacent pieces to the left, to the right, to the top, and to the bottom of the chosen piece (if there are any).</p>

<p>Consider the following position as an example:</p>

<p>bwbw <br>
wwww <br>
bbwb <br>
bwwb</p>

<p>Here &ldquo;b&rdquo; denotes pieces lying their black side up and &ldquo;w&rdquo; denotes pieces lying their white side up. If we choose to flip the 1st piece from the 3rd row (this choice is shown at the picture), then the field will become:</p>

<p>bwbw <br>
bwww <br>
wwwb <br>
wwwb <br></p>

<p>The goal of the game is to flip either all pieces white side up or all pieces black side up. You are to write a program that will search for the minimum number of rounds needed to achieve this goal.</p>

<p><strong>Input</strong></p>

<p>The input consists of 4 lines with 4 characters &ldquo;w&rdquo; or &ldquo;b&rdquo; each that denote game field position.</p>

<p><strong>Output</strong></p>

<p>Write to the output file a single integer number &ndash; the minimum number of rounds needed to achieve the goal of the game from the given position. If the goal is initially achieved, then write 0. If it&rsquo;s impossible to achieve the goal, then write the word &ldquo;Impossible&rdquo; (without quotes).</p>

<p><strong>Sample Input</strong></p>

<p>bwwb<br>
bbwb<br>
bwwb<br>
bwww<br></p>

<p><strong>Sample Output</strong></p>

<p>4</p>

<p><strong>Flip Game Image</strong></p>

<p><img src="http://poj.org/images/1753_1.jpg" alt="Flip Game Demo" /></p>

<h2>2.题意</h2>

<p>就是说选择4×4表格中的任意一个位置，然后这个位置和它的上下左右的位置都会转换颜色，然后就是问你怎样才能让整个4×4方格全是一种颜色，求一个最小的步数，不存在的话输出“Impossible”</p>

<h2>3.我的思路</h2>

<p>暴力求解，对步数进行限制，然后判定1步能否实现，然后判断2步能否实现，一直到判断出结果，但是这样的话其实只实现了0-5步是比较快的，但是6步以后就会运行时间增加很多，所以我的思路还是不正确的，但是还是贴下我的代码吧</p>

<h2>4.我的代码（只能实现5步以内比较快）</h2>

<pre>
  <code>
#include<iostream>

using namespace std;

typedef char State[4][4];

State state;

bool check(){
    char start = state[0][0];
    for (int i = 0;i<4;i++) 
        for (int j = 0;j<4;j++){
            if(state[i][j] != start) return false;  
        }
        return true;
}

char change(char p){
    if(p == 'b') return 'w';
    return 'b';
}

void changeColor(int i,int j){
    if(i - 1 >= 0) state[i-1][j] = change(state[i-1][j]);
    if(i + 1 < 4) state[i+1][j] = change(state[i+1][j]);
    if(j + 1 < 4) state[i][j+1] = change(state[i][j+1]);
    if(j - 1 >=0 ) state[i][j-1] = change(state[i][j-1]);
    state[i][j] = change(state[i][j]);
}


bool searchP(int step){

    if(step == 0) return false;

    for (int i = 0;i<4;i++) {
        for (int j = 0;j<4;j++) {
            changeColor(i,j);
            //printP();
            if(check()) return true;
            if(searchP(step-1)) return true;
            else 
                changeColor(i,j);

        }
    }
    return false;
}

int main(){

    while(true) {
        for (int i = 0;i<4;i++)     
            for (int j = 0;j<4;j++) cin>>state[i][j];
        if(check()) {
            cout&lt;&lt;"0"&lt;&lt;endl;
            continue;
        }
        int i = 0;
        while(++i){
            if(searchP(i)) break;
        }
        cout&lt;&lt;i&lt;&lt;endl;
    }

    return 0;
}
  </code>
</pre>


<h2>5.思路（正解？）</h2>

<p>我的方法之所以到后来速度很慢，是因为重复计算太多次了，正解应该是用一个VECTOR来保存状态，然后声明一个结构体，包含状态（即数组的状况）和已经走的步数，然后对这个栈进行维护，对栈中每一个元素进行广度遍历，再PUSH到VECTOR中，在建立一个vis的表，对已经运行过的VECTOR中的元素，不将其push进VECTOR中去，这样的话，如果存在的话，到时可以根据结构体中的步数来输出，如果到时VECTOR为空的话，就可以跳出，然后输出“Impossible”。</p>

<p>好的吧，只能说下面的代码可以保证我的输出肯定正确，但是运行时间呢，更慢了，要输出个Impossible的话，估计得刷个人人的时间了，很难忍受的，输出4以上的就会很慢了，主要是每次都要对string进行大量操作。弄得我都没有勇气提交POJ了</p>

<h2>6.代码（正确？）</h2>

<pre>
   <code>
#include&lt;iostream>
#include&lt;queue>
#include&lt;cstring>
#include&lt;string>
#include&lt;string.h>

using namespace std;

struct State
{
    string board;
    int step;
};

queue<State> vS;
string visList[1000000];
int pp = 0;

bool check(State s){
    string str = s.board;
    const char* ch = str.c_str();
    char start = ch[0];
    for (int i = 0;i<4;i++) {
        for (int j=0;j<4;j++) {
            if(start != ch[i*4+j]) return false;
        }
    }
    return true;
}

char change(char s){
    if(s == 'b') return 'w';
    return 'b';
}

bool isVis(string s){
    for (int i = 0;i<pp;i++) {
        if(strcmp(visList[i].c_str(),s.c_str())==0){
            return true;
        }
    }
    return false;
}

string changeColor(string ss, int x,int y) {
    char ch[20];
    const char* s = ss.c_str();
    strcpy(ch,ss.c_str());
    if(y - 1 >= 0) ch[x*4+y-1] = change(s[x*4+y-1]);
    if(y + 1 < 4) ch[x*4+y+1] = change(s[x*4+y+1]);
    if(x + 1 < 4) ch[(x+1)*4+y] = change(s[(x+1)*4+y]);
    if(x - 1 >= 0) ch[(x-1)*4+y] = change(s[(x-1)*4+y]);
    ch[x*4+y] = change(s[x*4+y]);
    string sss;
    sss.insert(0,ch);
    return sss;
}

void getResult(){
    State ss;
    bool op = false;
    while(!vS.empty()){
        ss = vS.front();
        if(check(ss)){
            op = true;
            break;
        }
        vS.pop();
        for (int i=0;i<4;i++) {
            for (int j=0;j<4;j++) {
                string s = changeColor(ss.board,i,j);
                if(isVis(s)) continue;
                int step = ss.step + 1;
                State ps;
                ps.board = s;
                ps.step = step;
                vS.push(ps);
                visList[pp++] = s;
            }
        }
    }
    if(op) cout&lt;&lt;ss.step&lt;&lt;endl;
    else cout&lt;&lt;"Impossible"&lt;&lt;endl;
}

int main(){

    while(true){
        State startS;
        while(!vS.empty()) vS.pop();
        string input;
        pp = 0;
        memset(visList,0,sizeof(0));
        for (int i = 0;i<4;i++) {
            cin>>input;
            startS.board.append(input);
        }
        visList[pp++] = input; 
        startS.step = 0;
        vS.push(startS);
        getResult();
    }
    return 0;
}
   </code>
</pre>


<h2>7.思路（正解）</h2>

<p>这回肯定是正确的思路了，之前的思路其实也没错，重要是这里还要用一种叫“位运算”的方式来保存状态，这样可以更快的判断是否访问过，修改状态，很多都很方便，而且速度快。</p>

<h2>8.代码（正解AC代码）</h2>

<pre>
  <code>
#include&lt;iostream>
#include&lt;queue>
#define M 65535
#define N 0

using namespace std;

struct state
{
    int data;
    int step;
};

char map[4][4];
int vis[65536];
queue<state> sQ;

int bfs(int data) {
    int i = 0;
    state l;
    state p;
    l.data = data;
    l.step = 0;
    sQ.push(l);
    vis[data] = 1;
    while(!sQ.empty()) {
        p = sQ.front();
        sQ.pop();
        if(p.data == M || p.data == N) return p.step;
        else{
            for (int i=0;i<16;i++) {
                int elem = p.data;
                elem = elem ^ (1 << i);
                if(i > 3)
                    elem = elem^(1 << (i - 4));
                if(i < 12)
                    elem = elem^(1 << (i + 4));
                if(i % 4 != 0)
                    elem = elem^(1 << (i - 1));
                if(i % 4 != 3)
                    elem = elem^(1 << (i + 1));
                state q;
                q.data = elem;
                q.step = p.step + 1;
                if(!vis[elem]){
                    vis[elem] = 1;
                    sQ.push(q);
                }
            }
        }
    }
    while(!sQ.empty())
        sQ.pop();
    return -1;
}

int main(){

    int i=0;
    int j=0;
    int data=0;
    int step=0;

    for (int i = 0;i < 4;i++) {
        gets(map[i]);
        for (int j=0;j<4;j++) {
            if(map[i][j] == 'b')
                data = (data << 1) + 1;
            else 
                data = data << 1;
        }
    }
    memset(vis,0,sizeof(vis));
    step = bfs(data);
    if(step == -1) cout&lt;&lt;"Impossible"&lt;&lt;endl;
    else cout&lt;&lt;step&lt;&lt;endl;
    return 0;
}
  </code>
</pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[POJ 1001-Exponentiation]]></title>
    <link href="http://xiao597896577.github.io/blog/2014/03/25/poj-1001-exponentiation/"/>
    <updated>2014-03-25T09:17:44+08:00</updated>
    <id>http://xiao597896577.github.io/blog/2014/03/25/poj-1001-exponentiation</id>
    <content type="html"><![CDATA[<h1>POJ 1001-Exponentiation 解题报告</h1>

<h2>1.原题</h2>

<p><strong>Description</strong></p>

<p>Problems involving the computation of exact values of very large magnitude and precision are common. For example, the computation of the national debt is a taxing experience for many computer systems.</p>

<p>This problem requires that you write a program to compute the exact value of Rn where R is a real number ( 0.0 &lt; R &lt; 99.999 ) and n is an integer such that 0 &lt; n &lt;= 25.</p>

<p><strong>Input</strong></p>

<p>The input will consist of a set of pairs of values for R and n. The R value will occupy columns 1 through 6, and the n value will be in columns 8 and 9.</p>

<p><strong>Output</strong></p>

<p>The output will consist of one line for each line of input giving the exact value of R<sup>n</sup>. Leading zeros should be suppressed in the output. Insignificant trailing zeros must not be printed. Don&rsquo;t print the decimal point if the result is an integer.</p>

<p><strong>Sample Input</strong></p>

<p>95.123 12<br>
0.4321 20<br>
5.1234 15<br>
6.7592  9<br>
98.999 10<br>
1.0100 12</p>

<p><strong>Sample Output</strong></p>

<p>548815620517731830194541.899025343415715973535967221869852721
.00000005148554641076956121994511276767154838481760200726351203835429763013462401
43992025569.928573701266488041146654993318703707511666295476720493953024
29448126.764121021618164430206909037173276672
90429072743629540498.107596019456651774561044010001
1.126825030131969720661201</p>

<p><strong>Hint</strong></p>

<p>If you don&rsquo;t know how to determine wheather encounted the end of input:
s is a string and n is an integer</p>

<h2>2.题目意思</h2>

<p>就是计算一个数N的M次方</p>

<h2>3.思路</h2>

<p>典型的大数题目，基本的数据类型肯定是hold不住的，还是用string，然后再一位一位调整，然后就是计算的时候用</p>

<blockquote><p>N的M次方 = N的M/2次方 * N的M/2次方</p></blockquote>

<p>这样更节省时间（本来是不想贴这个代码的，主要是这题太烦了，写了好久，是在不舍得，还是贴一下吧）</p>

<h2>4.代码</h2>

<pre>

<code>
#include&lt;iostream>
#include&lt;string>
#include&lt;strstream>

using namespace std;

string f_num;
int s_num = 0;

string numList[30];

string changeP(string s) {
    const char* p = s.c_str();
    int len = s.size();
    string k;
    for (int i = 0;i<len;i++) k += p[len-1-i];
    return k;
}

string addString(string ss,string s){
    string rp;
    const char* p = ss.c_str();
    int pL = ss.size();
    const char* o = s.c_str();
    int oL = s.size();
    int pp = 0;
    int oo = 0;
    int m = 0;
    while(pp<pL || oo<oL){
        int ppp = 0;
        int ooo = 0;
        if(pp<pL)
            ppp = p[pL-1-pp] - '0';
        if(oo<oL)
            ooo = o[oL-1-oo] - '0';
        int result = ppp + ooo + m;
        if(m == 1) m = 0;
        if(result >= 10) {
            result -= 10;
            m = 1;
        }
        rp += (result + '0');
        pp++;
        oo++;
    }
    if(m)
        rp += '1';
    return changeP(rp);
}

string calculate(string num,string num1) {
    const char* cList = num.c_str();
    const char* sList = num1.c_str();
    int len = num.size();
    int slen = num1.size();
    string result="";
    int p = 0;
    for (int i = slen-1;i>=0;i--) {
        string ss ;
        int pp = sList[i] - '0';
        int op = 0;
        for (int j = len-1;j>=0;j--) {
            int qq = cList[j] - '0';
            int re = pp * qq + op;
            if(op) op = 0;
            if(re >= 10) {
                op = re / 10;
                re = re % 10;
            }
            ss += (re + '0');
        }
        if(op) ss += (op+'0');
        ss = changeP(ss);
        for (int k = 0;k<p;k++) ss += '0';
        result = addString(result,ss);
        p++;
    }
    return result;
}

string getResult(string num,int sNum) {
    if(sNum == 1) return num;
    string k = calculate(num,num); 
    if(sNum % 2 == 0)
        return getResult(k,sNum/2);
    else return calculate(getResult(k,(sNum-1)/2),num);
}



int main(){

    while(cin>>f_num>>s_num) {
        int digit = 0;
        const char* cList = f_num.c_str();
        string num;
        int size = f_num.size();
        bool op = true;
        int up = 0;
        for (int i = size-1;i>=0;i--) {
            if(cList[i] == '0' && op){
                up ++;
                continue;
            }
            op = false;
            if(cList[i] == '.') digit = size-1-i;
            else num += f_num[i];
        }
        digit -= up;
        num = changeP(num);
        int mp = atoi(num.c_str());
        strstream ss;
        ss &lt;&lt; mp;
        ss >> num;
        string b = getResult(num,s_num);
        const char* plp = b.c_str();
        string p;
        if(digit * s_num >= b.size() && digit != 0) {
            for (int i = 0;i<digit*s_num+1;i++) {
                if(i == 0) p += ".";
                else if(i!=0 && i<=digit * s_num-b.size()) p += '0';
                else p+= plp[i+b.size()-digit*s_num-1];
            }
        }
        else if(digit * s_num &lt;b.size() && digit != 0){
            for (int i = 0;i&lt;b.size()+1;i++) {
                if(b.size()-digit*s_num > i) p+=plp[i];
                else if(i == b.size()-digit*s_num) p+='.';
                else p+= plp[i-1];
            }
        }else if(digit == 0){
            p = b;
        }
        cout&lt;&lt;p&lt;&lt;endl;
    }

    return 0;
}
</code>
</pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UVA 624 - CD]]></title>
    <link href="http://xiao597896577.github.io/blog/2014/03/24/uva-624-cd/"/>
    <updated>2014-03-24T15:17:03+08:00</updated>
    <id>http://xiao597896577.github.io/blog/2014/03/24/uva-624-cd</id>
    <content type="html"><![CDATA[<h1>UVA 624 &ndash; CD 解题报告</h1>

<h2>1.原题:</h2>

<p>You have a long drive by car ahead. You have a tape recorder, but unfortunately your best music is on CDs. You need to have it on tapes so the problem to solve is: you have a tape N minutes long. How to choose tracks from CD to get most out of tape space and have as short unused space as possible.</p>

<p>Assumptions:</p>

<p>number of tracks on the CD. does not exceed 20
no track is longer than N minutes
tracks do not repeat
length of each track is expressed as an integer number
N is also integer
Program should find the set of tracks which fills the tape best and print it in the same sequence as the tracks are stored on the CD</p>

<p><strong>Input</strong></p>

<p>Any number of lines. Each one contains value N, (after space) number of tracks and durations of the tracks. For example from first line in sample data: N=5, number of tracks=3, first track lasts for 1 minute, second one 3 minutes, next one 4 minutes</p>

<p><strong>Output</strong></p>

<p>Set of tracks (and durations) which are the correct solutions and string &#8220;sum:&ldquo; and sum of duration times.</p>

<p><strong>Sample Input</strong></p>

<p>5 3 1 3 4<br>
10 4 9 8 4 2<br>
20 4 10 5 7 4<br>
90 8 10 23 1 2 3 4 5 7<br>
45 8 4 10 44 43 12 9 8 2</p>

<p><strong>Sample Output</strong></p>

<p>1 4 sum:5<br>
8 2 sum:10<br>
10 5 4 sum:19<br>
10 23 1 2 3 4 5 7 sum:55<br>
4 10 12 9 8 2 sum:45<br></p>

<h2>2.中文大意</h2>

<p>就是给定规定的时间N，然后给M个磁带，每个磁带的时间都告诉你了，然后求不大于时间N的总时间是多少，将其序列和最接近N的总时间输出</p>

<h2>3.思路</h2>

<p>思路很简单了，就是用一个vis的数组先进行暴力枚举，将所有的时间和求出，然后每次算时间的时候，与N进行比较，再用一个int来存储与N的距离，即N-Sum，然后每次都进行判断，看是否小于N-Sum，这样就可以求出来了</p>

<h2>4.代码</h2>

<pre>
<code>
include&lt;iostream>
include&lt;cstring>
using namespace std;

int sum = 0;
int tapeNum = 0;
int numList[200];
int vis[200];
int resultSet[200];
bool qq = false;
int dis = 100000;
int nn = 0;

void checkSum(int index){
    int op = 0;
    for (int i = 0;i <= index;i++){
        if(vis[i])
            op += numList[i];
    }
    if(sum >= op) {
        if(sum - op < dis){
            if(sum - op == 0) qq = true;
            int pp = 0;
            dis = sum - op;
            for (int i = 0;i<=index;i++) {
                if(vis[i])
                    resultSet[pp++] = numList[i];
            }
            nn = pp;
        }
    }
}

void getResult(int index){
    if(qq || index == tapeNum) return ;
    vis[index] = 1;
    checkSum(index);
    getResult(index+1);
    vis[index] = 0;
    checkSum(index);
    getResult(index+1);
}

int main(){

    while(cin>>sum>>tapeNum) {
        memset(numList,0,sizeof(numList));
        memset(vis,0,sizeof(vis));
        memset(resultSet,0,sizeof(resultSet));
        qq = false;
        nn = 0;
        dis = 100000;
        for (int i = 0 ;i < tapeNum ;i ++) cin >> numList[i];
        getResult(0);
        for (int i = 0;i < nn;i++) {
            cout&lt;&lt;resultSet[i]&lt;&lt;" ";
        }
        cout&lt;&lt;"sum:"&lt;&lt;sum - dis&lt;&lt;endl;
    }
    return 0;
}
</code>
</pre>



]]></content>
  </entry>
  
</feed>
