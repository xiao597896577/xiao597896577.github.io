<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[My Octopress Blog]]></title>
  <link href="http://xiao597896577.github.io/atom.xml" rel="self"/>
  <link href="http://xiao597896577.github.io/"/>
  <updated>2014-03-25T09:37:36+08:00</updated>
  <id>http://xiao597896577.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[POJ 1001-Exponentiation]]></title>
    <link href="http://xiao597896577.github.io/blog/2014/03/25/poj-1001-exponentiation/"/>
    <updated>2014-03-25T09:17:44+08:00</updated>
    <id>http://xiao597896577.github.io/blog/2014/03/25/poj-1001-exponentiation</id>
    <content type="html"><![CDATA[<h1>POJ 1001-Exponentiation 解题报告</h1>

<h2>1.原题</h2>

<p><strong>Description</strong></p>

<p>Problems involving the computation of exact values of very large magnitude and precision are common. For example, the computation of the national debt is a taxing experience for many computer systems.</p>

<p>This problem requires that you write a program to compute the exact value of Rn where R is a real number ( 0.0 &lt; R &lt; 99.999 ) and n is an integer such that 0 &lt; n &lt;= 25.</p>

<p><strong>Input</strong></p>

<p>The input will consist of a set of pairs of values for R and n. The R value will occupy columns 1 through 6, and the n value will be in columns 8 and 9.</p>

<p><strong>Output</strong></p>

<p>The output will consist of one line for each line of input giving the exact value of R<sup>n</sup>. Leading zeros should be suppressed in the output. Insignificant trailing zeros must not be printed. Don&rsquo;t print the decimal point if the result is an integer.</p>

<p><strong>Sample Input</strong></p>

<p>95.123 12<br>
0.4321 20<br>
5.1234 15<br>
6.7592  9<br>
98.999 10<br>
1.0100 12</p>

<p><strong>Sample Output</strong></p>

<p>548815620517731830194541.899025343415715973535967221869852721
.00000005148554641076956121994511276767154838481760200726351203835429763013462401
43992025569.928573701266488041146654993318703707511666295476720493953024
29448126.764121021618164430206909037173276672
90429072743629540498.107596019456651774561044010001
1.126825030131969720661201</p>

<p><strong>Hint</strong></p>

<p>If you don&rsquo;t know how to determine wheather encounted the end of input:
s is a string and n is an integer</p>

<h2>2.题目意思</h2>

<p>就是计算一个数N的M次方</p>

<h2>3.思路</h2>

<p>典型的大数题目，基本的数据类型肯定是hold不住的，还是用string，然后再一位一位调整，然后就是计算的时候用</p>

<blockquote><p>N的M次方 = N的M/2次方 * N的M/2次方</p></blockquote>

<p>这样更节省时间（本来是不想贴这个代码的，主要是这题太烦了，写了好久，是在不舍得，还是贴一下吧）</p>

<h2>4.代码</h2>

<pre>

<code>
#include&lt;iostream>
#include&lt;string>
#include&lt;strstream>

using namespace std;

string f_num;
int s_num = 0;

string numList[30];

string changeP(string s) {
    const char* p = s.c_str();
    int len = s.size();
    string k;
    for (int i = 0;i<len;i++) k += p[len-1-i];
    return k;
}

string addString(string ss,string s){
    string rp;
    const char* p = ss.c_str();
    int pL = ss.size();
    const char* o = s.c_str();
    int oL = s.size();
    int pp = 0;
    int oo = 0;
    int m = 0;
    while(pp<pL || oo<oL){
        int ppp = 0;
        int ooo = 0;
        if(pp<pL)
            ppp = p[pL-1-pp] - '0';
        if(oo<oL)
            ooo = o[oL-1-oo] - '0';
        int result = ppp + ooo + m;
        if(m == 1) m = 0;
        if(result >= 10) {
            result -= 10;
            m = 1;
        }
        rp += (result + '0');
        pp++;
        oo++;
    }
    if(m)
        rp += '1';
    return changeP(rp);
}

string calculate(string num,string num1) {
    const char* cList = num.c_str();
    const char* sList = num1.c_str();
    int len = num.size();
    int slen = num1.size();
    string result="";
    int p = 0;
    for (int i = slen-1;i>=0;i--) {
        string ss ;
        int pp = sList[i] - '0';
        int op = 0;
        for (int j = len-1;j>=0;j--) {
            int qq = cList[j] - '0';
            int re = pp * qq + op;
            if(op) op = 0;
            if(re >= 10) {
                op = re / 10;
                re = re % 10;
            }
            ss += (re + '0');
        }
        if(op) ss += (op+'0');
        ss = changeP(ss);
        for (int k = 0;k<p;k++) ss += '0';
        result = addString(result,ss);
        p++;
    }
    return result;
}

string getResult(string num,int sNum) {
    if(sNum == 1) return num;
    string k = calculate(num,num); 
    if(sNum % 2 == 0)
        return getResult(k,sNum/2);
    else return calculate(getResult(k,(sNum-1)/2),num);
}



int main(){

    while(cin>>f_num>>s_num) {
        int digit = 0;
        const char* cList = f_num.c_str();
        string num;
        int size = f_num.size();
        bool op = true;
        int up = 0;
        for (int i = size-1;i>=0;i--) {
            if(cList[i] == '0' && op){
                up ++;
                continue;
            }
            op = false;
            if(cList[i] == '.') digit = size-1-i;
            else num += f_num[i];
        }
        digit -= up;
        num = changeP(num);
        int mp = atoi(num.c_str());
        strstream ss;
        ss &lt;&lt; mp;
        ss >> num;
        string b = getResult(num,s_num);
        const char* plp = b.c_str();
        string p;
        if(digit * s_num >= b.size() && digit != 0) {
            for (int i = 0;i<digit*s_num+1;i++) {
                if(i == 0) p += ".";
                else if(i!=0 && i<=digit * s_num-b.size()) p += '0';
                else p+= plp[i+b.size()-digit*s_num-1];
            }
        }
        else if(digit * s_num &lt;b.size() && digit != 0){
            for (int i = 0;i&lt;b.size()+1;i++) {
                if(b.size()-digit*s_num > i) p+=plp[i];
                else if(i == b.size()-digit*s_num) p+='.';
                else p+= plp[i-1];
            }
        }else if(digit == 0){
            p = b;
        }
        cout&lt;&lt;p&lt;&lt;endl;
    }

    return 0;
}
</code>
</pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UVA 624 - CD]]></title>
    <link href="http://xiao597896577.github.io/blog/2014/03/24/uva-624-cd/"/>
    <updated>2014-03-24T15:17:03+08:00</updated>
    <id>http://xiao597896577.github.io/blog/2014/03/24/uva-624-cd</id>
    <content type="html"><![CDATA[<h1>UVA 624 &ndash; CD 解题报告</h1>

<h2>1.原题:</h2>

<p>You have a long drive by car ahead. You have a tape recorder, but unfortunately your best music is on CDs. You need to have it on tapes so the problem to solve is: you have a tape N minutes long. How to choose tracks from CD to get most out of tape space and have as short unused space as possible.</p>

<p>Assumptions:</p>

<p>number of tracks on the CD. does not exceed 20
no track is longer than N minutes
tracks do not repeat
length of each track is expressed as an integer number
N is also integer
Program should find the set of tracks which fills the tape best and print it in the same sequence as the tracks are stored on the CD</p>

<p><strong>Input</strong></p>

<p>Any number of lines. Each one contains value N, (after space) number of tracks and durations of the tracks. For example from first line in sample data: N=5, number of tracks=3, first track lasts for 1 minute, second one 3 minutes, next one 4 minutes</p>

<p><strong>Output</strong></p>

<p>Set of tracks (and durations) which are the correct solutions and string &#8220;sum:&ldquo; and sum of duration times.</p>

<p><strong>Sample Input</strong></p>

<p>5 3 1 3 4<br>
10 4 9 8 4 2<br>
20 4 10 5 7 4<br>
90 8 10 23 1 2 3 4 5 7<br>
45 8 4 10 44 43 12 9 8 2</p>

<p><strong>Sample Output</strong></p>

<p>1 4 sum:5<br>
8 2 sum:10<br>
10 5 4 sum:19<br>
10 23 1 2 3 4 5 7 sum:55<br>
4 10 12 9 8 2 sum:45<br></p>

<h2>2.中文大意</h2>

<p>就是给定规定的时间N，然后给M个磁带，每个磁带的时间都告诉你了，然后求不大于时间N的总时间是多少，将其序列和最接近N的总时间输出</p>

<h2>3.思路</h2>

<p>思路很简单了，就是用一个vis的数组先进行暴力枚举，将所有的时间和求出，然后每次算时间的时候，与N进行比较，再用一个int来存储与N的距离，即N-Sum，然后每次都进行判断，看是否小于N-Sum，这样就可以求出来了</p>

<h2>4.代码</h2>

<pre>
<code>
include&lt;iostream>
include&lt;cstring>
using namespace std;

int sum = 0;
int tapeNum = 0;
int numList[200];
int vis[200];
int resultSet[200];
bool qq = false;
int dis = 100000;
int nn = 0;

void checkSum(int index){
    int op = 0;
    for (int i = 0;i <= index;i++){
        if(vis[i])
            op += numList[i];
    }
    if(sum >= op) {
        if(sum - op < dis){
            if(sum - op == 0) qq = true;
            int pp = 0;
            dis = sum - op;
            for (int i = 0;i<=index;i++) {
                if(vis[i])
                    resultSet[pp++] = numList[i];
            }
            nn = pp;
        }
    }
}

void getResult(int index){
    if(qq || index == tapeNum) return ;
    vis[index] = 1;
    checkSum(index);
    getResult(index+1);
    vis[index] = 0;
    checkSum(index);
    getResult(index+1);
}

int main(){

    while(cin>>sum>>tapeNum) {
        memset(numList,0,sizeof(numList));
        memset(vis,0,sizeof(vis));
        memset(resultSet,0,sizeof(resultSet));
        qq = false;
        nn = 0;
        dis = 100000;
        for (int i = 0 ;i < tapeNum ;i ++) cin >> numList[i];
        getResult(0);
        for (int i = 0;i < nn;i++) {
            cout&lt;&lt;resultSet[i]&lt;&lt;" ";
        }
        cout&lt;&lt;"sum:"&lt;&lt;sum - dis&lt;&lt;endl;
    }
    return 0;
}
</code>
</pre>



]]></content>
  </entry>
  
</feed>
