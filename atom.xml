<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[My Octopress Blog]]></title>
  <link href="http://xiao597896577.github.io/atom.xml" rel="self"/>
  <link href="http://xiao597896577.github.io/"/>
  <updated>2014-04-08T10:33:17+08:00</updated>
  <id>http://xiao597896577.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[POJ Training Plan]]></title>
    <link href="http://xiao597896577.github.io/blog/2014/04/08/poj-training-plan/"/>
    <updated>2014-04-08T23:59:59+08:00</updated>
    <id>http://xiao597896577.github.io/blog/2014/04/08/poj-training-plan</id>
    <content type="html"><![CDATA[<h2>1.初期：</h2>

<br>


<p><strong>一.基本算法</strong></p>

<p>(1)枚举.(<a href="http://xiao597896577.github.io/blog/2014/03/25/poj-1753-flip-game/">POJ1753</a>,<a href="http://xiao597896577.github.io/blog/2014/03/25/poj-2965-the-pilots-brothers-refrigerator/">POJ 2965</a>)
(2)贪心.(<a href="http://xiao597896577.github.io/blog/2014/03/26/poj-1328-radar-installationon/">POJ1328</a>,<a href="http://xiao597896577.github.io/blog/2014/03/26/poj-2109-power-of-cryptography/">POJ2109</a>,<a href="http://xiao597896577.github.io/blog/2014/03/27/poj-2586-y2k-accounting-bug/">POJ2586</a>)
(3)递归和分治法<br>
(4)递推<br>
(5)构造法(<a href="http://xiao597896577.github.io/blog/2014/03/27/poj-3295-tautology/">POJ3295</a>)<br>
(6)模拟法(<a href="http://xiao597896577.github.io/blog/2014/04/08/poj-1068-parencodings/">POJ1068</a>)<br></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[POJ 1068 Parencodings]]></title>
    <link href="http://xiao597896577.github.io/blog/2014/04/08/poj-1068-parencodings/"/>
    <updated>2014-04-08T09:48:02+08:00</updated>
    <id>http://xiao597896577.github.io/blog/2014/04/08/poj-1068-parencodings</id>
    <content type="html"><![CDATA[<h2>1.原题</h2>

<p><strong>Description</strong></p>

<p>Let S = s1 s2&hellip;s2n be a well-formed string of parentheses. S can be encoded in two different ways:</p>

<pre> 
<br>1.q By an integer sequence P = p1 p2...pn where pi is the number of left parentheses before the ith right parenthesis in S (P-sequence).</br> 
<br>2.q By an integer sequence W = w1 w2...wn where for each right parenthesis, say a in S, we associate an integer which is the number of right parentheses counting from the matched left parenthesis of a up to a. (W-sequence).</br> 
</pre>


<p>Following is an example of the above encodings:</p>

<pre><code>S       (((()()())))

P-sequence      4 5 6666

W-sequence      1 1 1456
</code></pre>

<p>Write a program to convert P-sequence of a well-formed string to the W-sequence of the same string.</p>

<p><strong>Input</strong></p>

<p>The first line of the input contains a single integer t (1 &lt;= t &lt;= 10), the number of test cases, followed by the input data for each test case. The first line of each test case is an integer n (1 &lt;= n &lt;= 20), and the second line is the P-sequence of a well-formed string. It contains n positive integers, separated with blanks, representing the P-sequence.</p>

<br>**Output**


<p>The output file consists of exactly t lines corresponding to test cases. For each test case, the output line should contain n integers describing the W-sequence of the string corresponding to its given P-sequence.</p>

<p><strong>Sample Input</strong></p>

<pre>
2
6
4 5 6 6 6 6
9 
4 6 6 6 6 8 9 9 9
</pre>


<p><strong>Sample Output</strong></p>

<pre>
1 1 1 4 5 6
1 1 2 4 5 1 1 3 9
</pre>


<h2>2.题意</h2>

<p>有两种方式</p>

<pre>
    1.找到一个右括号，然后输出他前面的左括号的数目
    2.找到一个右括号，然后找到与它匹配的左括号，然后输出他们之间的右括号的数目（包括自己）
</pre>


<p>现在就是给你第一种方式的输入，然后叫你求出第二种方式的输出</p>

<h2>3.思路</h2>

<p>这道题是在那个训练计划中是模拟题，其实我也不懂什么是模拟了，就说说自己的思路吧，其实很简单了，就是根据第一种方式，就可以很简单的求出所对应的括号序列，然后根据得出来的括号序列，记录下括号总个数，然后将整个扫一遍，然后找到右括号，就开始进入方法，如果是还是右括号，则个数加1，如果是左括号，看之前是否有右括号，没有的话，则这个左括号与该右括号是匹配的，则可以输出个数。</p>

<h2>4.代码##（Accept）</h2>

<pre>
<code>
#include&lt;iostream>
#include&lt;cstring>

using namespace std;

int num = 0;
char list[50];

void checkResult(int index){
    int op = 1;
    int kk = 0;
    for (int j=index-1;j>=0;j--) {
        if(list[j] == ')'){
            kk++;
            op ++;
        }
        else {
            if(kk == 0) {
                break;
            }
            else{
                kk--;
            }
        }
    }
    cout << op;
}

int main(){

    int testcase = 0;
    cin>>testcase;
    while(testcase--) {
        cin>>num;
        int before = 0;
        int p = 0;
        int index = 0;
        memset(list,0,sizeof(list));
        for (int i = 0; i < num;i++){
            cin>>p;
            if(i == 0){
                for (;index < p-before;index++) list[index] = '(';
            }else{
                index++;
                for (int j = 0;j < p-before;j++) {
                    list[index+j] = '(';
                    index++;
                }
            }
            list[index] = ')';
            before = p;
        }
        bool pp = false;
        for (int i = 0;i <= index;i++) { 
            if(list[i] == ')') {
                if(pp) cout << " ";
                else pp = true;
                checkResult(i);
            }
        }
        cout << endl;
    }
    return 0;
}
</code>
</pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Head First in Design Pattern(1) Strategy]]></title>
    <link href="http://xiao597896577.github.io/blog/2014/03/30/head-first-in-design-pattern-1-strategy/"/>
    <updated>2014-03-30T20:45:20+08:00</updated>
    <id>http://xiao597896577.github.io/blog/2014/03/30/head-first-in-design-pattern-1-strategy</id>
    <content type="html"><![CDATA[<h2>1.策略模式</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;策略模式就是定义了算法族，分别封装起来，让他们之间可以相互的替换，此模式让算法的变化独立于使用算法的客户。</p>

<h2>2.类图</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说上去感觉好像可高端的样子，还是直接看类图吧，看完类图就一目了然了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[POJ 3295 Tautology]]></title>
    <link href="http://xiao597896577.github.io/blog/2014/03/27/poj-3295-tautology/"/>
    <updated>2014-03-27T23:42:02+08:00</updated>
    <id>http://xiao597896577.github.io/blog/2014/03/27/poj-3295-tautology</id>
    <content type="html"><![CDATA[<h2>1.原题</h2>

<p><strong>Description</strong></p>

<p>WFF &lsquo;N PROOF is a logic game played with dice. Each die has six faces representing some subset of the possible symbols K, A, N, C, E, p, q, r, s, t. A Well-formed formula (WFF) is any string of these symbols obeying the following rules:</p>

<blockquote><p>1.p, q, r, s, and t are WFFs<br>
2.if w is a WFF, Nw is a WFF<br>
3.if w and x are WFFs, Kwx, Awx, Cwx, and Ewx are WFFs.</p></blockquote>

<p>The meaning of a WFF is defined as follows:</p>

<blockquote><p>1.p, q, r, s, and t are logical variables that may take on the value 0 (false) or 1 (true).<br>
2.K, A, N, C, E mean and, or, not, implies, and equals as defined in the truth table below.</p></blockquote>

<p>Definitions of K, A, N, C, and E <br>
  w  &nbsp;&nbsp;x   &nbsp;&nbsp; Kwx   &nbsp;&nbsp;  Awx&nbsp;&nbsp;      Nw   &nbsp;&nbsp;  Cwx&nbsp;&nbsp;     Ewx<br>
  1  &nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;    1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     &nbsp;1   &nbsp;&nbsp;&nbsp;&nbsp;   0    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  1   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>
  1  &nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;    0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     0<br>
  0&nbsp;&nbsp;  1  &nbsp;&nbsp;&nbsp;  0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     0<br>
  0  &nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;    0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     1<br><br>
A tautology is a WFF that has value 1 (true) regardless of the values of its variables. For example, ApNp is a tautology because it is true regardless of the value of p. On the other hand, ApNq is not, because it has the value 0 for p=0, q=1.</p>

<p>You must determine whether or not a WFF is a tautology.</p>

<p><strong>Input</strong></p>

<p>Input consists of several test cases. Each test case is a single line containing a WFF with no more than 100 symbols. A line containing 0 follows the last case.</p>

<p><strong>Output</strong></p>

<p>For each test case, output a line containing tautology or not as appropriate.</p>

<p><strong>Sample Input</strong></p>

<p>ApNp<br>
ApNq<br>
0<br></p>

<p><strong>Sample Output</strong></p>

<p>tautology<br>
not</p>

<h2>2.题意</h2>

<p>就是说给你一个string的字符串，然后就是有一套规则，p, q, r, s, t可以任意是0或1，然后K，A，N，C，E的与前面的字符匹配的值在上面的表格中，即“K11”为“1”，“N1”为“0”等，然后在最后看结果是否为0，如果有一种情况为0，则输出not,如果没有这种情况的话，那就输出tautology。</p>

<h2>3.思路</h2>

<p>我的思路：就是先用map存储一个序列，比如mapList[&ldquo;K11&rdquo;] = &lsquo;1&rsquo;,然后（p，q，r，s，t）从（0，0，0，0，0）到（1，1，1，1，1）的所有情况全部遍历一遍，然后判断是否为零，方法的话就是在从字符串最后一位开始，一直往前，每次的话将map中的值压栈，在再出栈，知道最后出现结果为止，判断是否为0</p>

<p>大神思路：本来这道题在训练计划中，是属于“构造法”的，但是我感觉我的思路丝毫没有啥构造的感觉，然后网上查了一下，才发现还可以这样做，就是压栈和出栈的思路是对的，只要是表格中K可以表示成x&amp;y，A是x||y,C是(!x)||y,E是x==y,N是!x，这样的话，就不用那么麻烦的判断了。这样才是构造啊，这是厉害！！完全没有想到</p>

<h2>4.代码(别人的)</h2>

<p>贴个链接
<a href="http://blog.csdn.net/lyy289065406/article/details/6642766" title="代码">http://blog.csdn.net/lyy289065406/article/details/6642766</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[POJ 2586 Y2K Accounting Bug]]></title>
    <link href="http://xiao597896577.github.io/blog/2014/03/27/poj-2586-y2k-accounting-bug/"/>
    <updated>2014-03-27T22:39:36+08:00</updated>
    <id>http://xiao597896577.github.io/blog/2014/03/27/poj-2586-y2k-accounting-bug</id>
    <content type="html"><![CDATA[<h2>1.原题</h2>

<p><strong>Description</strong></p>

<p>Accounting for Computer Machinists (ACM) has sufferred from the Y2K bug and lost some vital data for preparing annual report for MS Inc.
All what they remember is that MS Inc. posted a surplus or a deficit each month of 1999 and each month when MS Inc. posted surplus, the amount of surplus was s and each month when MS Inc. posted deficit, the deficit was d. They do not remember which or how many months posted surplus or deficit. MS Inc., unlike other companies, posts their earnings for each consecutive 5 months during a year. ACM knows that each of these 8 postings reported a deficit but they do not know how much. The chief accountant is almost sure that MS Inc. was about to post surplus for the entire year of 1999. Almost but not quite.</p>

<p>Write a program, which decides whether MS Inc. suffered a deficit during 1999, or if a surplus for 1999 was possible, what is the maximum amount of surplus that they can post.</p>

<p><strong>Input</strong></p>

<p>Input is a sequence of lines, each containing two positive integers s and d.</p>

<p><strong>Output</strong></p>

<p>For each line of input, output one line containing either a single integer giving the amount of surplus for the entire year, or output Deficit if it is impossible.</p>

<p><strong>Sample Input</strong></p>

<p>59 237<br>
375 743<br>
200000 849694<br>
2500000 8000000<br></p>

<p><strong>Sample Output</strong></p>

<p>116<br>
28<br>
300612<br>
Deficit</p>

<h2>2.题意</h2>

<p>银行有盈利和亏损，然后是给你两个值，一个是亏损的钱，一个是盈利的钱，每个月一定是其中的一个数字，然后就是要满足任意连续五个月都要是亏损的，然后看12个月是否可以盈利</p>

<h2>3.思路</h2>

<p>直接暴力枚举，12个月分别亏损和盈利，然后每次都判定是否满足连续五个月是亏损的这个条件，然后再计算那个12个月的总收入，看是否大于0，大于的话，直接输出，否则的话就继续，最后如果还是没有的话，则输出Deficit。</p>

<h2>4.代码(略)</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[POJ 2109 Power of Cryptography]]></title>
    <link href="http://xiao597896577.github.io/blog/2014/03/26/poj-2109-power-of-cryptography/"/>
    <updated>2014-03-26T19:11:08+08:00</updated>
    <id>http://xiao597896577.github.io/blog/2014/03/26/poj-2109-power-of-cryptography</id>
    <content type="html"><![CDATA[<h2>1.原题</h2>

<p><strong>Description</strong></p>

<p>Current work in cryptography involves (among other things) large prime numbers and computing powers of numbers among these primes. Work in this area has resulted in the practical use of results from number theory and other branches of mathematics once considered to be only of theoretical interest.
This problem involves the efficient computation of integer roots of numbers.
Given an integer n>=1 and an integer p>= 1 you have to write a program that determines the n th positive root of p. In this problem, given such integers n and p, p will always be of the form k to the nth. power, for an integer k (this integer is what your program must find).</p>

<p><strong>Input</strong></p>

<p>The input consists of a sequence of integer pairs n and p with each integer on a line by itself. For all such pairs 1&lt;=n&lt;= 200, 1&lt;=p&lt;10<sup>101</sup> and there exists an integer k, 1&lt;=k&lt;=10<sup>9</sup> such that k<sup>n</sup> = p.</p>

<br>


<p><strong>Output</strong></p>

<p>For each integer pair n and p the value k should be printed, i.e., the number k such that k n =p.</p>

<p><strong>Sample Input</strong></p>

<p>2 16<br>
3 27<br>
7 4357186184021382204544</p>

<p><strong>Sample Output</strong></p>

<p>4<br>
3<br>
1234<br></p>

<h2>2.题意</h2>

<p>简单来说，题意就是说给你M和N，然后要你求出K，使得K的M次方等于N</p>

<h2>3.思路</h2>

<p>由于结果的范围已经限制，是在1-10的9次方之间，很明显应该是用二分法来解决了，然后剩下的工作就是大数据的运算了，代码的话，我是从网上找的，思路的话，和我的思路基本一致</p>

<h2>4.代码</h2>

<pre>
 <code>

#include &lt;iostream>
#include &lt;string.h>

using namespace std;

void swap_str(char str[]) {
    int len = strlen(str);
    for (int i=0; i&lt;len/2; i++) {
        int tmp = str[i];
        str[i] = str[len-i-1];
        str[len-i-1] = tmp;
    }
}

void my_mul(char str[], int x) {
    int len = strlen(str);
    int cp = 0, i, tmp;
    swap_str(str);

    for (i=0; i&lt;len; i++) {
        tmp = (str[i]-'0')*x + cp;
        str[i] = (tmp%10) + '0';
        cp = tmp / 10;
    }

    while (cp) {
        str[i++] = (cp%10) + '0';
        cp /= 10;
    }

    while ('0'==str[i-1] && i>1)
        i--;
    str[i] = '\0';

    swap_str(str);
}

int my_numCmp(char str1[], char str2[]) {
    int len1, len2;
    len1 = strlen(str1);
    len2 = strlen(str2);

    if (len1 > len2)
        return 1;
    if (len1 < len2)
        return -1;

    return strcmp(str1, str2);
}

void my_pow(char str[], int k, int n) {
    str[0] = '1', str[1] = '\0';
    while (n--) {
        my_mul(str, k);
    }
}

int my_binary_search(int n, char str[]) {
    int high = 1e9, low = 0;
    int mid;
    char tot[2005];

    while (low < high) {
        mid = low + (high-low)/2;
        my_pow(tot, mid, n);
        int tmp = my_numCmp(tot, str);
        if (0 == tmp)
            return mid;
        if (tmp < 0)
            low = mid + 1;
        else
            high = mid;
    }
    return mid;
}

int main() {
    char str[105];
    int n;
    while (scanf("%d%s", &n, str) != EOF) {
        printf("%d\n", my_binary_search(n, str));
    }

    return 0;
}
   </code>
</pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[POJ 1328 Radar Installationon]]></title>
    <link href="http://xiao597896577.github.io/blog/2014/03/26/poj-1328-radar-installationon/"/>
    <updated>2014-03-26T15:16:20+08:00</updated>
    <id>http://xiao597896577.github.io/blog/2014/03/26/poj-1328-radar-installationon</id>
    <content type="html"><![CDATA[<h2>1.原题</h2>

<p><strong>Description</strong></p>

<p>Assume the coasting is an infinite straight line. Land is in one side of coasting, sea in the other. Each small island is a point locating in the sea side. And any radar installation, locating on the coasting, can only cover d distance, so an island in the sea can be covered by a radius installation, if the distance between them is at most d.</p>

<p>We use Cartesian coordinate system, defining the coasting is the x-axis. The sea side is above x-axis, and the land side below. Given the position of each island in the sea, and given the distance of the coverage of the radar installation, your task is to write a program to find the minimal number of radar installations to cover all the islands. Note that the position of an island is represented by its x-y coordinates.</p>

<p>Figure A Sample Input of Radar Installations</p>

<p><strong>Input</strong></p>

<p>The input consists of several test cases. The first line of each case contains two integers n (1&lt;=n&lt;=1000) and d, where n is the number of islands in the sea and d is the distance of coverage of the radar installation. This is followed by n lines each containing two integers representing the coordinate of the position of each island. Then a blank line follows to separate the cases.</p>

<p>The input is terminated by a line containing pair of zeros</p>

<p><strong>Output</strong></p>

<p>For each test case output one line consisting of the test case number followed by the minimal number of radar installations needed. &ldquo;-1&rdquo; installation means no solution for that case.</p>

<p><strong>Sample Input</strong></p>

<p>3 2<br>
1 2<br>
-3 1<br>
2 1<br></p>

<p>1 2<br>
0 2</p>

<p>0 0<br></p>

<p><strong>Sample Output</strong></p>

<p>Case 1: 2<br>
Case 2: 1</p>

<h2>2.题意</h2>

<p>就是说在坐标轴上给你n个点（y >= 0），然后有半径为M的圆，且圆心都在x轴上，问你至少多少个圆可以包括所有的左边</p>

<h2>3.思路</h2>

<p>就是先把所有的N个点所可以对应的在x轴上的坐标区间求出来，然后再用sort将x从小到大排列，然后再从0到N-1，现设start为第一个点的y（即区间右边），然后在判断下一个点，如果下一个点的y小于start，则说明这个区间包含在前一个区间中，再将start设置成这个点的y，如果下一个点的x（区间左边）大于start，则这个区间与上一个区间没有交集，则可以将圆的个数加一，然后再将start设置成这个点的y。只是有交集的情况可以直接过滤到，因为对变量没有影响。</p>

<h2>4.代码</h2>

<pre>
   <code>
#include&lt;iostream>
#include&lt;algorithm>
#include&lt;cmath>
#include&lt;cstring>

using namespace std;

struct island
{
    double x;
    double y;
};

island is[1010];
int islandNum = 0;

int operator < (const island& a,const island& b){
    return a.x < b.x;
}

int main(){

    
    int distance = 0;
    int pp = 1;
    while(cin>>islandNum>>distance && (islandNum != 0 || distance != 0)){
        double maxNum = 0.0;
        for (int i = 0;i < islandNum;i++){
            cin>>is[i].x>>is[i].y;
            maxNum = max(maxNum,is[i].y);
        }
        if(maxNum > distance) {
            cout&lt;&lt;"Case "&lt;&lt;pp++&lt;&lt;": -1"&lt;&lt;endl;
            continue;
        }
        for (int i = 0;i < islandNum;i++) {
            double d = sqrt(distance * distance - is[i].y * is[i].y);
            double temp = is[i].x;
            is[i].x = temp - d;
            is[i].y = temp + d;
        }
        sort(is,is+islandNum);
        int circleNum = 1;
        double start = is[0].y;
        for (int i = 1;i < islandNum;i++) {
            if(is[i].y < start) start = is[i].y;
            else if(start < is[i].x) {
                start = is[i].y;
                circleNum++;
            }
        }
        cout&lt;&lt;"Case "&lt;&lt;pp++&lt;&lt;": "&lt;&lt;circleNum&lt;&lt;endl;
    }

    return 0;
}
   </code>
</pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[POJ 2965 The Pilots Brothers' refrigerator]]></title>
    <link href="http://xiao597896577.github.io/blog/2014/03/25/poj-2965-the-pilots-brothers-refrigerator/"/>
    <updated>2014-03-25T22:37:04+08:00</updated>
    <id>http://xiao597896577.github.io/blog/2014/03/25/poj-2965-the-pilots-brothers-refrigerator</id>
    <content type="html"><![CDATA[<h1>POJ 2965 The Pilots Brothers&#8217; Refrigerator</h1>

<h2>1.原题</h2>

<p><strong>Description</strong></p>

<p>The game “The Pilots Brothers: following the stripy elephant” has a quest where a player needs to open a refrigerator.</p>

<p>There are 16 handles on the refrigerator door. Every handle can be in one of two states: open or closed. The refrigerator is open only when all handles are open. The handles are represented as a matrix 4х4. You can change the state of a handle in any location [i, j] (1 ≤ i, j ≤ 4). However, this also changes states of all handles in row i and all handles in column j.</p>

<p>The task is to determine the minimum number of handle switching necessary to open the refrigerator.</p>

<p><strong>Input</strong></p>

<p>The input contains four lines. Each of the four lines contains four characters describing the initial state of appropriate handles. A symbol “+” means that the handle is in closed state, whereas the symbol “−” means “open”. At least one of the handles is initially closed.</p>

<p><strong>Output</strong></p>

<p>The first line of the input contains N – the minimum number of switching. The rest N lines describe switching sequence. Each of the lines contains a row number and a column number of the matrix separated by one or more spaces. If there are several solutions, you may give any one of them.</p>

<p><strong>Sample Input</strong><br>
-+ - -<br>
- - - -<br>
- - - -<br>
-+ - -</p>

<p><strong>Sample Output</strong></p>

<p>6<br>
1 1<br>
1 3<br>
1 4<br>
4 1<br>
4 3<br>
4 4</p>

<h2>2.题意</h2>

<p>题目意思就是有一个4×4的方格，然后是要你从里面任意选择出一个格子，然后它自己，以及它所在行，它所在列的所有的位置都变成相反的，比如‘+’变成‘-’，‘-’变成‘+’，然后问你，最少选多少次格子，可以让所有格子都变成‘-’</p>

<h2>3.思路</h2>

<p>思路的话，很简单了，此题和上面的POJ1753是一个类型的，基本就是照办，就是位运算+队列的压缩存储状态,这里面多了一个，就是要输出每一步，这样的话，就用了数组来存储每次保存的状态，然后递归来输出结果</p>

<h2>4.代码</h2>

<pre>
  <code>
#include&lt;iostream>
#include&lt;queue>
#include&lt;cstring>
#include&lt;string>
#include&lt;string.h>
#define M 65535

using namespace std;

struct state
{
    int data;
    int step;
    int pre;
    int pos;
};

int dir[16] = {4383,8751,17487,34959,4593,8946,17652,35064,7953,12066,20292,36744,61713,61986,62532,63624};
queue<state> sList;
int visList[M+1];

state ssList[(1<<16) +1];

void printP(state s) {
    if(s.pre != -1){
        printP(ssList[s.pre]);
        cout&lt;&lt; s.pos / 4 + 1&lt;&lt;" "&lt;&lt;s.pos % 4 + 1&lt;&lt;endl;
    }
}

void getResult(){

    state ss;
    bool op = false;
    while(!sList.empty()){

        ss = sList.front();
        sList.pop();

        if(ss.data == M) {
            cout&lt;&lt;ss.step&lt;&lt;&lt;endl;
            printP(ss);
            break;
        }

        for (int i = 0; i<16;i++) {
            int temp = ss.data ^ dir[15-i];
            if(visList[temp]) continue;
            state sss;
            sss.data = temp;
            sss.step = ss.step + 1;
            sss.pre = ss.data;
            sss.pos = i;
            ssList[sss.data] = sss;
            visList[temp] = 1;
            sList.push(sss);
        }

    }
}

int main(){
    while(!sList.empty()) sList.pop();
    memset(visList,0,sizeof(visList));
    memset(ssList,0,sizeof(ssList));
    state start;
    int data = 0;
    string s;
    for (int i = 0; i < 4; i++) {
        cin>>s;
        const char* map = s.c_str();
        for (int j=0;j<4;j++) {
            if(map[j] == '-')
                data = (data << 1) + 1;
            else 
                data = (data << 1);
        }
    }
    visList[data] = 1;
    start.data = data;
    start.step = 0;
    start.pre = -1;
    sList.push(start);
    ssList[data] = start;
    getResult();

    return 0;
}

  </code>
</pre>


<h2>5.后续</h2>

<p>1）其实这道题先开始是TLE的，主要是因为先开始我维护的是一张string的路径，即存储在struct里面的，每次都进行添加每次的行走的路线，不知道是因为string的操作运行时间太长还是其他什么原因，就是会TLE，而且在cmd中显示还会卡壳的。后来用数字的话，速度就快多了。这个还要再看一下。</p>

<p>2）就是这个题先开始用c++的编译器的时候，会报TLE的，但是后来我改成G++的编译器后，就没有TLE了，直接AC。这个原因也要再查一下</p>

<p>3）吐槽一下，这道题花了一个晚上，感觉有点坑爹，但是是自己的第二道位运算，现在感觉位运算了解一些了吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[POJ 1753 Flip Game]]></title>
    <link href="http://xiao597896577.github.io/blog/2014/03/25/poj-1753-flip-game/"/>
    <updated>2014-03-25T11:28:42+08:00</updated>
    <id>http://xiao597896577.github.io/blog/2014/03/25/poj-1753-flip-game</id>
    <content type="html"><![CDATA[<h1>POJ 1753-Flip Game</h1>

<h2>1.原题</h2>

<p><strong>Description</strong></p>

<p>Flip game is played on a rectangular 4x4 field with two-sided pieces placed on each of its 16 squares. One side of each piece is white and the other one is black and each piece is lying either it&rsquo;s black or white side up. Each round you flip 3 to 5 pieces, thus changing the color of their upper side from black to white and vice versa. The pieces to be flipped are chosen every round according to the following rules: <br>
 1.Choose any one of the 16 pieces. <br>
 2.Flip the chosen piece and also all adjacent pieces to the left, to the right, to the top, and to the bottom of the chosen piece (if there are any).</p>

<p>Consider the following position as an example:</p>

<p>bwbw <br>
wwww <br>
bbwb <br>
bwwb</p>

<p>Here &ldquo;b&rdquo; denotes pieces lying their black side up and &ldquo;w&rdquo; denotes pieces lying their white side up. If we choose to flip the 1st piece from the 3rd row (this choice is shown at the picture), then the field will become:</p>

<p>bwbw <br>
bwww <br>
wwwb <br>
wwwb <br></p>

<p>The goal of the game is to flip either all pieces white side up or all pieces black side up. You are to write a program that will search for the minimum number of rounds needed to achieve this goal.</p>

<p><strong>Input</strong></p>

<p>The input consists of 4 lines with 4 characters &ldquo;w&rdquo; or &ldquo;b&rdquo; each that denote game field position.</p>

<p><strong>Output</strong></p>

<p>Write to the output file a single integer number &ndash; the minimum number of rounds needed to achieve the goal of the game from the given position. If the goal is initially achieved, then write 0. If it&rsquo;s impossible to achieve the goal, then write the word &ldquo;Impossible&rdquo; (without quotes).</p>

<p><strong>Sample Input</strong></p>

<p>bwwb<br>
bbwb<br>
bwwb<br>
bwww<br></p>

<p><strong>Sample Output</strong></p>

<p>4</p>

<p><strong>Flip Game Image</strong></p>

<p><img src="http://poj.org/images/1753_1.jpg" alt="Flip Game Demo" /></p>

<h2>2.题意</h2>

<p>就是说选择4×4表格中的任意一个位置，然后这个位置和它的上下左右的位置都会转换颜色，然后就是问你怎样才能让整个4×4方格全是一种颜色，求一个最小的步数，不存在的话输出“Impossible”</p>

<h2>3.我的思路</h2>

<p>暴力求解，对步数进行限制，然后判定1步能否实现，然后判断2步能否实现，一直到判断出结果，但是这样的话其实只实现了0-5步是比较快的，但是6步以后就会运行时间增加很多，所以我的思路还是不正确的，但是还是贴下我的代码吧</p>

<h2>4.我的代码（只能实现5步以内比较快）</h2>

<pre>
  <code>
#include<iostream>

using namespace std;

typedef char State[4][4];

State state;

bool check(){
    char start = state[0][0];
    for (int i = 0;i<4;i++) 
        for (int j = 0;j<4;j++){
            if(state[i][j] != start) return false;  
        }
        return true;
}

char change(char p){
    if(p == 'b') return 'w';
    return 'b';
}

void changeColor(int i,int j){
    if(i - 1 >= 0) state[i-1][j] = change(state[i-1][j]);
    if(i + 1 < 4) state[i+1][j] = change(state[i+1][j]);
    if(j + 1 < 4) state[i][j+1] = change(state[i][j+1]);
    if(j - 1 >=0 ) state[i][j-1] = change(state[i][j-1]);
    state[i][j] = change(state[i][j]);
}


bool searchP(int step){

    if(step == 0) return false;

    for (int i = 0;i<4;i++) {
        for (int j = 0;j<4;j++) {
            changeColor(i,j);
            //printP();
            if(check()) return true;
            if(searchP(step-1)) return true;
            else 
                changeColor(i,j);

        }
    }
    return false;
}

int main(){

    while(true) {
        for (int i = 0;i<4;i++)     
            for (int j = 0;j<4;j++) cin>>state[i][j];
        if(check()) {
            cout&lt;&lt;"0"&lt;&lt;endl;
            continue;
        }
        int i = 0;
        while(++i){
            if(searchP(i)) break;
        }
        cout&lt;&lt;i&lt;&lt;endl;
    }

    return 0;
}
  </code>
</pre>


<h2>5.思路（正解？）</h2>

<p>我的方法之所以到后来速度很慢，是因为重复计算太多次了，正解应该是用一个VECTOR来保存状态，然后声明一个结构体，包含状态（即数组的状况）和已经走的步数，然后对这个栈进行维护，对栈中每一个元素进行广度遍历，再PUSH到VECTOR中，在建立一个vis的表，对已经运行过的VECTOR中的元素，不将其push进VECTOR中去，这样的话，如果存在的话，到时可以根据结构体中的步数来输出，如果到时VECTOR为空的话，就可以跳出，然后输出“Impossible”。</p>

<p>好的吧，只能说下面的代码可以保证我的输出肯定正确，但是运行时间呢，更慢了，要输出个Impossible的话，估计得刷个人人的时间了，很难忍受的，输出4以上的就会很慢了，主要是每次都要对string进行大量操作。弄得我都没有勇气提交POJ了</p>

<h2>6.代码（正确？）</h2>

<pre>
   <code>
#include&lt;iostream>
#include&lt;queue>
#include&lt;cstring>
#include&lt;string>
#include&lt;string.h>

using namespace std;

struct State
{
    string board;
    int step;
};

queue<State> vS;
string visList[1000000];
int pp = 0;

bool check(State s){
    string str = s.board;
    const char* ch = str.c_str();
    char start = ch[0];
    for (int i = 0;i<4;i++) {
        for (int j=0;j<4;j++) {
            if(start != ch[i*4+j]) return false;
        }
    }
    return true;
}

char change(char s){
    if(s == 'b') return 'w';
    return 'b';
}

bool isVis(string s){
    for (int i = 0;i<pp;i++) {
        if(strcmp(visList[i].c_str(),s.c_str())==0){
            return true;
        }
    }
    return false;
}

string changeColor(string ss, int x,int y) {
    char ch[20];
    const char* s = ss.c_str();
    strcpy(ch,ss.c_str());
    if(y - 1 >= 0) ch[x*4+y-1] = change(s[x*4+y-1]);
    if(y + 1 < 4) ch[x*4+y+1] = change(s[x*4+y+1]);
    if(x + 1 < 4) ch[(x+1)*4+y] = change(s[(x+1)*4+y]);
    if(x - 1 >= 0) ch[(x-1)*4+y] = change(s[(x-1)*4+y]);
    ch[x*4+y] = change(s[x*4+y]);
    string sss;
    sss.insert(0,ch);
    return sss;
}

void getResult(){
    State ss;
    bool op = false;
    while(!vS.empty()){
        ss = vS.front();
        if(check(ss)){
            op = true;
            break;
        }
        vS.pop();
        for (int i=0;i<4;i++) {
            for (int j=0;j<4;j++) {
                string s = changeColor(ss.board,i,j);
                if(isVis(s)) continue;
                int step = ss.step + 1;
                State ps;
                ps.board = s;
                ps.step = step;
                vS.push(ps);
                visList[pp++] = s;
            }
        }
    }
    if(op) cout&lt;&lt;ss.step&lt;&lt;endl;
    else cout&lt;&lt;"Impossible"&lt;&lt;endl;
}

int main(){

    while(true){
        State startS;
        while(!vS.empty()) vS.pop();
        string input;
        pp = 0;
        memset(visList,0,sizeof(0));
        for (int i = 0;i<4;i++) {
            cin>>input;
            startS.board.append(input);
        }
        visList[pp++] = input; 
        startS.step = 0;
        vS.push(startS);
        getResult();
    }
    return 0;
}
   </code>
</pre>


<h2>7.思路（正解）</h2>

<p>这回肯定是正确的思路了，之前的思路其实也没错，重要是这里还要用一种叫“位运算”的方式来保存状态，这样可以更快的判断是否访问过，修改状态，很多都很方便，而且速度快。</p>

<h2>8.代码（正解AC代码）</h2>

<pre>
  <code>
#include&lt;iostream>
#include&lt;queue>
#define M 65535
#define N 0

using namespace std;

struct state
{
    int data;
    int step;
};

char map[4][4];
int vis[65536];
queue<state> sQ;

int bfs(int data) {
    int i = 0;
    state l;
    state p;
    l.data = data;
    l.step = 0;
    sQ.push(l);
    vis[data] = 1;
    while(!sQ.empty()) {
        p = sQ.front();
        sQ.pop();
        if(p.data == M || p.data == N) return p.step;
        else{
            for (int i=0;i<16;i++) {
                int elem = p.data;
                elem = elem ^ (1 << i);
                if(i > 3)
                    elem = elem^(1 << (i - 4));
                if(i < 12)
                    elem = elem^(1 << (i + 4));
                if(i % 4 != 0)
                    elem = elem^(1 << (i - 1));
                if(i % 4 != 3)
                    elem = elem^(1 << (i + 1));
                state q;
                q.data = elem;
                q.step = p.step + 1;
                if(!vis[elem]){
                    vis[elem] = 1;
                    sQ.push(q);
                }
            }
        }
    }
    while(!sQ.empty())
        sQ.pop();
    return -1;
}

int main(){

    int i=0;
    int j=0;
    int data=0;
    int step=0;

    for (int i = 0;i < 4;i++) {
        gets(map[i]);
        for (int j=0;j<4;j++) {
            if(map[i][j] == 'b')
                data = (data << 1) + 1;
            else 
                data = data << 1;
        }
    }
    memset(vis,0,sizeof(vis));
    step = bfs(data);
    if(step == -1) cout&lt;&lt;"Impossible"&lt;&lt;endl;
    else cout&lt;&lt;step&lt;&lt;endl;
    return 0;
}
  </code>
</pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[POJ 1001-Exponentiation]]></title>
    <link href="http://xiao597896577.github.io/blog/2014/03/25/poj-1001-exponentiation/"/>
    <updated>2014-03-25T09:17:44+08:00</updated>
    <id>http://xiao597896577.github.io/blog/2014/03/25/poj-1001-exponentiation</id>
    <content type="html"><![CDATA[<h1>POJ 1001-Exponentiation 解题报告</h1>

<h2>1.原题</h2>

<p><strong>Description</strong></p>

<p>Problems involving the computation of exact values of very large magnitude and precision are common. For example, the computation of the national debt is a taxing experience for many computer systems.</p>

<p>This problem requires that you write a program to compute the exact value of Rn where R is a real number ( 0.0 &lt; R &lt; 99.999 ) and n is an integer such that 0 &lt; n &lt;= 25.</p>

<p><strong>Input</strong></p>

<p>The input will consist of a set of pairs of values for R and n. The R value will occupy columns 1 through 6, and the n value will be in columns 8 and 9.</p>

<p><strong>Output</strong></p>

<p>The output will consist of one line for each line of input giving the exact value of R<sup>n</sup>. Leading zeros should be suppressed in the output. Insignificant trailing zeros must not be printed. Don&rsquo;t print the decimal point if the result is an integer.</p>

<p><strong>Sample Input</strong></p>

<p>95.123 12<br>
0.4321 20<br>
5.1234 15<br>
6.7592  9<br>
98.999 10<br>
1.0100 12</p>

<p><strong>Sample Output</strong></p>

<p>548815620517731830194541.899025343415715973535967221869852721
.00000005148554641076956121994511276767154838481760200726351203835429763013462401
43992025569.928573701266488041146654993318703707511666295476720493953024
29448126.764121021618164430206909037173276672
90429072743629540498.107596019456651774561044010001
1.126825030131969720661201</p>

<p><strong>Hint</strong></p>

<p>If you don&rsquo;t know how to determine wheather encounted the end of input:
s is a string and n is an integer</p>

<h2>2.题目意思</h2>

<p>就是计算一个数N的M次方</p>

<h2>3.思路</h2>

<p>典型的大数题目，基本的数据类型肯定是hold不住的，还是用string，然后再一位一位调整，然后就是计算的时候用</p>

<blockquote><p>N的M次方 = N的M/2次方 * N的M/2次方</p></blockquote>

<p>这样更节省时间（本来是不想贴这个代码的，主要是这题太烦了，写了好久，是在不舍得，还是贴一下吧）</p>

<h2>4.代码</h2>

<pre>

<code>
#include&lt;iostream>
#include&lt;string>
#include&lt;strstream>

using namespace std;

string f_num;
int s_num = 0;

string numList[30];

string changeP(string s) {
    const char* p = s.c_str();
    int len = s.size();
    string k;
    for (int i = 0;i<len;i++) k += p[len-1-i];
    return k;
}

string addString(string ss,string s){
    string rp;
    const char* p = ss.c_str();
    int pL = ss.size();
    const char* o = s.c_str();
    int oL = s.size();
    int pp = 0;
    int oo = 0;
    int m = 0;
    while(pp<pL || oo<oL){
        int ppp = 0;
        int ooo = 0;
        if(pp<pL)
            ppp = p[pL-1-pp] - '0';
        if(oo<oL)
            ooo = o[oL-1-oo] - '0';
        int result = ppp + ooo + m;
        if(m == 1) m = 0;
        if(result >= 10) {
            result -= 10;
            m = 1;
        }
        rp += (result + '0');
        pp++;
        oo++;
    }
    if(m)
        rp += '1';
    return changeP(rp);
}

string calculate(string num,string num1) {
    const char* cList = num.c_str();
    const char* sList = num1.c_str();
    int len = num.size();
    int slen = num1.size();
    string result="";
    int p = 0;
    for (int i = slen-1;i>=0;i--) {
        string ss ;
        int pp = sList[i] - '0';
        int op = 0;
        for (int j = len-1;j>=0;j--) {
            int qq = cList[j] - '0';
            int re = pp * qq + op;
            if(op) op = 0;
            if(re >= 10) {
                op = re / 10;
                re = re % 10;
            }
            ss += (re + '0');
        }
        if(op) ss += (op+'0');
        ss = changeP(ss);
        for (int k = 0;k<p;k++) ss += '0';
        result = addString(result,ss);
        p++;
    }
    return result;
}

string getResult(string num,int sNum) {
    if(sNum == 1) return num;
    string k = calculate(num,num); 
    if(sNum % 2 == 0)
        return getResult(k,sNum/2);
    else return calculate(getResult(k,(sNum-1)/2),num);
}



int main(){

    while(cin>>f_num>>s_num) {
        int digit = 0;
        const char* cList = f_num.c_str();
        string num;
        int size = f_num.size();
        bool op = true;
        int up = 0;
        for (int i = size-1;i>=0;i--) {
            if(cList[i] == '0' && op){
                up ++;
                continue;
            }
            op = false;
            if(cList[i] == '.') digit = size-1-i;
            else num += f_num[i];
        }
        digit -= up;
        num = changeP(num);
        int mp = atoi(num.c_str());
        strstream ss;
        ss &lt;&lt; mp;
        ss >> num;
        string b = getResult(num,s_num);
        const char* plp = b.c_str();
        string p;
        if(digit * s_num >= b.size() && digit != 0) {
            for (int i = 0;i<digit*s_num+1;i++) {
                if(i == 0) p += ".";
                else if(i!=0 && i<=digit * s_num-b.size()) p += '0';
                else p+= plp[i+b.size()-digit*s_num-1];
            }
        }
        else if(digit * s_num &lt;b.size() && digit != 0){
            for (int i = 0;i&lt;b.size()+1;i++) {
                if(b.size()-digit*s_num > i) p+=plp[i];
                else if(i == b.size()-digit*s_num) p+='.';
                else p+= plp[i-1];
            }
        }else if(digit == 0){
            p = b;
        }
        cout&lt;&lt;p&lt;&lt;endl;
    }

    return 0;
}
</code>
</pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UVA 624 - CD]]></title>
    <link href="http://xiao597896577.github.io/blog/2014/03/24/uva-624-cd/"/>
    <updated>2014-03-24T15:17:03+08:00</updated>
    <id>http://xiao597896577.github.io/blog/2014/03/24/uva-624-cd</id>
    <content type="html"><![CDATA[<h1>UVA 624 &ndash; CD 解题报告</h1>

<h2>1.原题:</h2>

<p>You have a long drive by car ahead. You have a tape recorder, but unfortunately your best music is on CDs. You need to have it on tapes so the problem to solve is: you have a tape N minutes long. How to choose tracks from CD to get most out of tape space and have as short unused space as possible.</p>

<p>Assumptions:</p>

<p>number of tracks on the CD. does not exceed 20
no track is longer than N minutes
tracks do not repeat
length of each track is expressed as an integer number
N is also integer
Program should find the set of tracks which fills the tape best and print it in the same sequence as the tracks are stored on the CD</p>

<p><strong>Input</strong></p>

<p>Any number of lines. Each one contains value N, (after space) number of tracks and durations of the tracks. For example from first line in sample data: N=5, number of tracks=3, first track lasts for 1 minute, second one 3 minutes, next one 4 minutes</p>

<p><strong>Output</strong></p>

<p>Set of tracks (and durations) which are the correct solutions and string &#8220;sum:&ldquo; and sum of duration times.</p>

<p><strong>Sample Input</strong></p>

<p>5 3 1 3 4<br>
10 4 9 8 4 2<br>
20 4 10 5 7 4<br>
90 8 10 23 1 2 3 4 5 7<br>
45 8 4 10 44 43 12 9 8 2</p>

<p><strong>Sample Output</strong></p>

<p>1 4 sum:5<br>
8 2 sum:10<br>
10 5 4 sum:19<br>
10 23 1 2 3 4 5 7 sum:55<br>
4 10 12 9 8 2 sum:45<br></p>

<h2>2.中文大意</h2>

<p>就是给定规定的时间N，然后给M个磁带，每个磁带的时间都告诉你了，然后求不大于时间N的总时间是多少，将其序列和最接近N的总时间输出</p>

<h2>3.思路</h2>

<p>思路很简单了，就是用一个vis的数组先进行暴力枚举，将所有的时间和求出，然后每次算时间的时候，与N进行比较，再用一个int来存储与N的距离，即N-Sum，然后每次都进行判断，看是否小于N-Sum，这样就可以求出来了</p>

<h2>4.代码</h2>

<pre>
<code>
include&lt;iostream>
include&lt;cstring>
using namespace std;

int sum = 0;
int tapeNum = 0;
int numList[200];
int vis[200];
int resultSet[200];
bool qq = false;
int dis = 100000;
int nn = 0;

void checkSum(int index){
    int op = 0;
    for (int i = 0;i <= index;i++){
        if(vis[i])
            op += numList[i];
    }
    if(sum >= op) {
        if(sum - op < dis){
            if(sum - op == 0) qq = true;
            int pp = 0;
            dis = sum - op;
            for (int i = 0;i<=index;i++) {
                if(vis[i])
                    resultSet[pp++] = numList[i];
            }
            nn = pp;
        }
    }
}

void getResult(int index){
    if(qq || index == tapeNum) return ;
    vis[index] = 1;
    checkSum(index);
    getResult(index+1);
    vis[index] = 0;
    checkSum(index);
    getResult(index+1);
}

int main(){

    while(cin>>sum>>tapeNum) {
        memset(numList,0,sizeof(numList));
        memset(vis,0,sizeof(vis));
        memset(resultSet,0,sizeof(resultSet));
        qq = false;
        nn = 0;
        dis = 100000;
        for (int i = 0 ;i < tapeNum ;i ++) cin >> numList[i];
        getResult(0);
        for (int i = 0;i < nn;i++) {
            cout&lt;&lt;resultSet[i]&lt;&lt;" ";
        }
        cout&lt;&lt;"sum:"&lt;&lt;sum - dis&lt;&lt;endl;
    }
    return 0;
}
</code>
</pre>



]]></content>
  </entry>
  
</feed>
